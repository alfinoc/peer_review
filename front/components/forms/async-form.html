<link rel="import" href="/components/standard/paper-toast/paper-toast.html">
<link rel="import" href="/components/standard/core-ajax/core-ajax.html">
<link rel="import" href="/components/forms/question-input.html">
<link rel="import" href="/components/standard/paper-icon-button/paper-icon-button.html">

<polymer-element name="async-form">
   <template>
      <link rel="stylesheet" type="text/css" href="async-form.css">
      <core-ajax id="ajax"></core-ajax>
      <div class="buttonbar" layout horizontal>
            <h1 flex>{{ header }}</h1>
            <template if="{{ auto }}">
               <paper-icon-button icon="remove" on-click="{{ removeInput }}" self-center>
               </paper-icon-button>
               <paper-icon-button icon="add" on-click="{{ addInput }}" self-center>
               </paper-icon-button>
            </template>
         </div>
      <div>
         <content class="keyed"></content>
         <template repeat="{{ text, i in prefill }}">
            <question-input number="{{ i + 1 }}"
                            placeholderText="{{ placeholderText }}"
                            defaultText="{{ text }}">
            </question-input>
         </template>
         <span></span> <!-- hack to get nth-child indexing to work with above -->
         <template repeat="{{ i in range(blankInputs) }}">
            <question-input number="{{ i + prefill.length }}"
                            placeholderText="{{ placeholderText }}">
            </question-input>
         </template>
      </div>
      <core-ajax id="ajax" url="{{ url }}" method="POST"></core-ajax>
   </template>
      <script>

Polymer('async-form', {
   publish: {
      header: 'Edit Form',
      blankInputs: 0,
      auto: false,
      placeholderText: '',
      prefill: [],
      url: '/'
   },

   created: function() {
      prefill = [];

      // A function from list of question responses to JSON-ready object.
      // The object will be set as the sole 'data' field to outgoing AJAX
      // requests.
      this.serialize = function(keyed, numbered) { return {}; };
   },

   submit: function() {
      var numbered = this.getNumbered().map(function(input) {
         return input.getResponse();
      });
      var keyed = {};
      this.getKeyed().forEach(function(input) {
         if (input.key == null)
            console.log('Encountered keyed input without a key.')
         else
            keyed[input.key] = input.getResponse();
      });
      this.$.ajax.params = this.serialize(keyed, numbered);
      this.$.ajax.go();
   },

   jsonString: function(obj) {
      return JSON.stringify(obj);
   },

   range: function(max) {
      var res = [];
      for (var i = 1; i <= max; i++) res.push(i);
      return res;
   },

   addInput: function() {
      this.blankInputs++;
      var inputs = this.getNumbered();
      inputs[inputs.length - 1].scrollIntoView();
   },

   removeInput: function() {
      var inputs = this.getNumbered();
      if (inputs.length > 1 && !(inputs[inputs.length - 1].getResponse())) {
         this.blankInputs--;
      }
   },

   getNumbered: function() {
      return this.querySelectorAll('::shadow question-input').array();
   },

   getKeyed: function() {
      return this.querySelectorAll('question-input').array();
   }
});

   </script>
</polymer-element>
